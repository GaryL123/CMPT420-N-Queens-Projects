package TestNQueens;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Arrays;
import java.util.Random;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;

public class TestNQueens extends JFrame {
    private static final long serialVersionUID = 1L;
    private final int boardSize;
    private final String algorithm;
    private JButton[][] squares;
    private JTextArea statusText;
    private int steps;
    private double progress;

    public TestNQueens(int boardSize, String algorithm) {
        super("N-Queens Problem");
        this.boardSize = boardSize;
        this.algorithm = algorithm;
        this.steps = 0;
        this.progress = 0;

        // Create the chess board
        JPanel board = new JPanel(new GridLayout(boardSize, boardSize));
        board.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2));
        squares = new JButton[boardSize][boardSize];
        for (int i = 0; i < boardSize; i++) {
            for (int j = 0; j < boardSize; j++) {
                squares[i][j] = new JButton("");
                squares[i][j].setEnabled(false);
                squares[i][j].setBackground((i + j) % 2 == 0 ? Color.WHITE : Color.LIGHT_GRAY);
                board.add(squares[i][j]);
            }
        }

        // Create the control panel
        JPanel controlPanel = new JPanel(new GridLayout(2, 1));
        JButton solveButton = new JButton("Solve");
        solveButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                solveNQueens();
            }
        });
        JButton resetButton = new JButton("Reset");
        resetButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                resetBoard();
            }
        });
        controlPanel.add(solveButton);
        controlPanel.add(resetButton);

        // Create the status text area
        statusText = new JTextArea();
        statusText.setEditable(false);

        // Add components to the window
        add(board, BorderLayout.CENTER);
        add(controlPanel, BorderLayout.NORTH);
        add(statusText, BorderLayout.SOUTH);

        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(600, 600);
        setLocationRelativeTo(null);

        resetBoard();
    }

    private void resetBoard() {
        for (int i = 0; i < boardSize; i++) {
            for (int j = 0; j < boardSize; j++) {
                squares[i][j].setEnabled(true);
                squares[i][j].setText("");
            }
        }
        statusText.setText("");
        steps = 0;
        progress = 0;
    }

    private void solveNQueens() {
        if (algorithm.equals("Steepest Ascent Hill Climbing")) {
            solveNQueensSteepestAscent();
        } else {
            int[] rows = new int[boardSize];
            Arrays.fill(rows, -1);
            solveNQueensBacktracking(0, rows);
        }
    }

    private void solveNQueensSteepestAscent() {
        int[] board = new int[boardSize];
        Random random = new Random();
        for (int i = 0; i < boardSize; i++) {
            board[i] = random.nextInt(boardSize);
        }
        int currentHeuristic = calculateHeuristic(board);
        	while (currentHeuristic > 0) {
            int bestRow = -1;
            int bestColumn = -1;
            int bestHeuristic = currentHeuristic;
            for (int i = 0; i < boardSize; i++) {
                for (int j = 0; j < boardSize; j++) {
                    if (j != board[i]) {
                        int[] newBoard = Arrays.copyOf(board, boardSize);
                        newBoard[i] = j;
                        int newHeuristic = calculateHeuristic(newBoard);
                        if (newHeuristic < bestHeuristic) {
                            bestRow = i;
                            bestColumn = j;
                            bestHeuristic = newHeuristic;
                        }
                    }
                }
            }
            if (bestHeuristic == currentHeuristic) {
                // Stuck at a local optimum
                statusText.setText("Stuck at a local optimum!");
                return;
            }
            board[bestRow] = bestColumn;
            currentHeuristic = bestHeuristic;
            updateBoard(board);
        }
        statusText.setText("Solved in " + steps + " steps! (" + String.format("%.2f", progress) + "%)");
    }

    private int calculateHeuristic(int[] board) {
        int heuristic = 0;
        for (int i = 0; i < boardSize; i++) {
            for (int j = i + 1; j < boardSize; j++) {
                if (board[i] == board[j] || Math.abs(board[i] - board[j]) == j - i) {
                    heuristic++;
                }
            }
        }
        return heuristic;
    }

    private boolean solveNQueensBacktracking(int col, int[] rows) {
        if (col == boardSize) {
            updateBoard(rows);
            statusText.setText("Solved in " + steps + " steps! (" + String.format("%.2f", progress) + "%)");
            return true;
        } else {
            for (int row = 0; row < boardSize; row++) {
                boolean valid = true;
                for (int i = 0; i < col; i++) {
                    if (rows[i] == row || rows[i] - i == row - col || rows[i] + i == row + col) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    rows[col] = row;
                    if (solveNQueensBacktracking(col + 1, rows)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    private void updateBoard(int[] rows) {
        for (int i = 0; i < boardSize; i++) {
            for (int j = 0; j < boardSize; j++) {
                squares[i][j].setEnabled(false);
                if (j == rows[i]) {
                    squares[i][j].setText("Q");
                } else {
                    squares[i][j].setText("");
                }
            }
        }
        steps++;
        progress = (double) steps / (double) (algorithm.equals("Steepest Ascent Hill Climbing") ? 20000 : 10000) * 100.0;
        statusText.setText("Step " + steps + " (" + String.format("%.2f", progress) + "%)");
    }

    public static void main(String[] args) {
        int boardSize = Integer.parseInt(JOptionPane.showInputDialog("Enter the board size:"));
        String algorithm = (String) JOptionPane.showInputDialog(null, "Select an algorithm:", "Algorithm Selection",
                JOptionPane.DEFAULT_OPTION, null, new String[] { "Steepest Ascent Hill Climbing",             "Backtracking" }, 0);

        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                new TestNQueens(boardSize, algorithm).setVisible(true);
            }
        });
    }
}

