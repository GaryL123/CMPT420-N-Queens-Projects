package nqueens;

import java.util.Random;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;

public class NQueens extends JFrame implements ActionListener {
    
	private int n;
    private Random rand;
    private boolean solved;
    private int steps;
    private int plateauCount;
    private int ridgeCount;
    
    private JPanel inputPanel;
    private JLabel inputLabel;
    private JTextField inputField;
    private JButton createBoardButton;

    private JPanel boardPanel;
    private JButton[][] tiles;
    private boolean[][] queens;
    private ArrayList<boolean[][]> boards;
    private int boardsIndex;

    private JPanel buttonsPanel;
    private JButton leftButton;
    private JButton rightButton;
    private JButton backtrackingButton;
    private JButton hillclimbingButton;
    private JButton resetButton;

    private JTextArea outputArea;

    // GUI Window for 'Enter N:'
    public NQueens() {
        
        // Basic construction of the 'Enter N' GUI window
        setTitle("NQueens");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(500, 100);
        setLayout(new BorderLayout());
        
        // Creates the inputPanel of the GUI
        inputPanel = new JPanel();
        inputLabel = new JLabel("Enter N: ");
        inputField = new JTextField(5);
        inputField.addActionListener(this);
        createBoardButton = new JButton("Enter");
        createBoardButton.addActionListener(this);

        inputPanel.add(inputLabel);
        inputPanel.add(inputField);
        inputPanel.add(createBoardButton);

        add(inputPanel);

        setVisible(true);
    }

    // Main GUI window
    public NQueens(int n) {
        
        // GUI is split into 3 sections
        // boardPanel contains the NQueens board
        // buttonPanel contains the Backtracking, Hillclimbing, Reset, and L/R traversal buttons
        // outputArea contains the text outputted by either algorithm

        this.n = n;
        solved = false;
        rand = new Random();

        // Basic construction of the GUI window
        setTitle("NQueens"); // Title of the program
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Makes the program stop running when the window is closed. It would continue to run within NetBeans otherwise
        setSize(800, 600); // Width/Height of the window
        setLayout(new BorderLayout()); // Lets us layout the different panels of the GUI into different parts of the window

        // Creates the boardPanel area of the GUI
        boardPanel = new JPanel(new GridLayout(n, n)); // Constructs a new panel with a grid layout
        tiles = new JButton[n][n];
        queens = new boolean[n][n];
        boardsIndex = -1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                tiles[j][i] = new JButton();
                tiles[j][i].setOpaque(true);
                tiles[j][i].setPreferredSize(new Dimension(50, 50)); // Sets the size of the board's tiles
                boardPanel.add(tiles[j][i]);
            }
        }
        boardPanel.setPreferredSize(new Dimension(500, 500)); // Sets dimension of the board panel
        boardPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK)); // Adds a border to the board panel
        add(boardPanel, BorderLayout.WEST); // Orients the board to the left side of the window

        // Creates the buttons panel of the GUI
        buttonsPanel = new JPanel();
        leftButton = new JButton("<");
        leftButton.addActionListener(this);
        leftButton.setEnabled(false);
        rightButton = new JButton(">");
        rightButton.addActionListener(this);
        rightButton.setEnabled(false);
        backtrackingButton = new JButton("Recursive Backtracking");
        backtrackingButton.addActionListener(this);
        hillclimbingButton = new JButton("Steepest Ascent Hillclimbing");
        hillclimbingButton.addActionListener(this);
        resetButton = new JButton("Reset");
        resetButton.addActionListener(this);
        buttonsPanel.add(leftButton);
        buttonsPanel.add(backtrackingButton);
        buttonsPanel.add(hillclimbingButton);
        buttonsPanel.add(resetButton);
        buttonsPanel.add(rightButton);
        add(buttonsPanel, BorderLayout.SOUTH);

        // Creates the outputArea of the GUI
        outputArea = new JTextArea();
        outputArea.setEditable(false); // Makes it so the outputArea cannot be editted
        JScrollPane scrollPane = new JScrollPane(outputArea); // Makes the outputArea scrollable
        add(scrollPane, BorderLayout.CENTER);

        setVisible(true);
    }

    public void backtracking(int row, int[] count) {
        // If this is the first step of the backtracking algorithm, a queen is randomly placed somewhere in the first column
        if(count[0] == 0) {
            int startingQueen = rand.nextInt(n - 1);
            queens[0][startingQueen] = true;
            tiles[0][startingQueen].setBackground(Color.BLACK);
            count[0]++;
            outputArea.append(count[0] + ". Placed starting queen at (" + 1 + ", " + (startingQueen + 1) + ")\n");
        }

        // If the algorithm has reached the last row, returns true and prints out the number of steps required to reach a solution.
        if(row == n) {
            // Returned if solution found
            solved = true;
            outputArea.append("Solved in: " + count[0] + " steps\n"); 
            return;
        }

        // Checks for conflicts with the current queen assignments. If no conflicts, places a queen
        // then recursively calls the backtracking method for the next row. If it is not the first step
        // of the algorithm or no solution has been found, the method picks back up here.
        for (int col = 0; col < n; col++) {
            // Calls the backtrackingConflicts method to check for conflicts
            if (!backtrackingConflicts(row, col)) {
                queens[row][col] = true; // Adds a queen to this position on the board
                tiles[row][col].setBackground(Color.BLACK); // Sets the color of this position
                count[0]++; // Increments steps taken
                outputArea.append(count[0] + ". Placed queen at (" + (row + 1) + ", " + (col + 1) + ")\n"); // Adds this to the outputArea
                backtracking(row + 1, count); // Recursively calls the algo for the next row and updates the step count for the next recursion
                if (solved) {
                    return; // Breaks out of for loop when solution is found, else continues
                }
                queens[row][col] = false; // Removes a queen from this position if there are conflicts
                tiles[row][col].setBackground(null); // Removes the color from this position
                count[0]++; // Increments steps taken.
                outputArea.append(count[0] + ". Removed queen at (" + (row + 1) + ", " + (col + 1) + ")\n"); // Adds this to the outputArea
            }
        }
        
    }

    public boolean backtrackingConflicts(int row, int col) {
        for (int i = 0; i < row; i++) {
            // Returns a conflict if there is a queen in the same row or column
            if (queens[row][i] || queens[i][col]) {
                return true;
            }

            // Returns a conflict if there is a queen to the left diagonally
            int leftDiagonal = col - (row - i);
            if (leftDiagonal >= 0 && queens[i][leftDiagonal]) {
                return true;
            }

            // Returns a conflict if there is a queen to the right diagonally
            int rightDiagonal = col + (row - i);
            if (rightDiagonal < n && queens[i][rightDiagonal]) {
                return true;
            }
        }
        return false;
    }

    public void hillclimbing(int[] attempts) {
        long start = System.currentTimeMillis(); // Gets the current time before the hillclimbing algo starts
        boards = new ArrayList<>();
        
        int successes = 0;
        int failures = 0;
        solved = false;
        
        for (int i = 0; i < 20; i++) {
            hillClimbingPlaceQueensRandomly();
            int h = hillclimbingCalculateHeuristic();
            
            while (h > 0) {
                int minH = Integer.MAX_VALUE;
                int[] move = null;
                
                for (int j = 0; j < n; j++) {
                    int currentRow = hillclimbingGetQueenRow(j);
                    
                    for (int k = 0; k < n; k++) {
                        if (k != currentRow) {
                            hillclimbingMoveQueen(j, k);
                            int newH = hillclimbingCalculateHeuristic();
                            
                            if (newH < minH) {
                                minH = newH;
                                move = new int[]{j, k};
                            }
                            hillclimbingMoveQueen(j, currentRow);
                        }
                    }
                }
                
                if (h == minH) { plateauCount++; }
                
                if (h > minH) { ridgeCount++; }
                
                if (plateauCount == n) {
                	outputArea.append("Attempt #" + attempts[0] + ", failure\n");
                	outputArea.append("Plateau error: Stuck at a plateau \n");
                    outputArea.append("Heuristic " + hillclimbingCalculateHeuristic() + "\n \n");
                    attempts[0]++;
                    failures++;
                    break;
                 }
                 if (ridgeCount == n) {

                	outputArea.append("Attempt #" + attempts[0] + ", failure\n");
                	outputArea.append("Ridge error: Stuck at a ridge \n");
                    outputArea.append("Heuristic: " + hillclimbingCalculateHeuristic() + "\n \n");
                    attempts[0]++;
                    failures++;
                    break;
                }
                
                if (minH >= h) {
                    outputArea.append("Attempt #" + attempts[0] + ", failure\n");
                	outputArea.append("Local maxima error: Stuck at a local maxima \n");
                    outputArea.append("Heuristic: " + hillclimbingCalculateHeuristic() + "\n \n");
                    boolean[][] newBoard = new boolean[n][n];
                    for (int a = 0; a < n; a++)
                        for (int b = 0; b < n; b++)
                        {
                            newBoard[b][a] = queens[b][a];
                        }
                    boards.add(newBoard);
                    attempts[0]++;
                    failures++;
                    break;
                }
                
                hillclimbingMoveQueen(move[0], move[1]);
                h = minH;
                
                if (h == 0) {
                    //outputArea.append("Heuristic = " + h + "\n");
                    outputArea.append("Attempt #" + attempts[0] + ", success\n \n");
                    boolean[][] newBoard = new boolean[n][n];
                    for (int a = 0; a < n; a++)
                        for (int b = 0; b < n; b++)
                        {
                            newBoard[b][a] = queens[b][a];
                        }
                    boards.add(newBoard);
                    attempts[0]++;
                    successes++;
                    break;
                }
            }
        }
        
        long end = System.currentTimeMillis(); // Gets the current time after the backtracking algo stops
        outputArea.append("Successes: " + successes + "\nFailures: " + failures + "\n");
        double percentSuccess = (successes/20.0)*100;
        String percentSuccessStr = String.format("%.2f", percentSuccess);
        outputArea.append("Found a solution " + percentSuccessStr + "% of the time\n");
        outputArea.append("Elapsed time: " + (end - start) + " ms\n\n");
        
        boardsIndex = boards.size() - 1;
        outputArea.append("Showing Attempt #" + (boardsIndex + 1) + "\n");
        //outputArea.append("Heuristic " + hillclimbingCalculateHeuristic() + "\n");
        leftButton.setEnabled(true);
        solved = true;
    }

    private int hillclimbingCalculateHeuristic() {
        int h = 0;
        for (int i = 0; i < n; i++) {
            int row = hillclimbingGetQueenRow(i);
            for (int j = i + 1; j < n; j++) {
                int otherRow = hillclimbingGetQueenRow(j);
                if (row == otherRow || Math.abs(row - otherRow) == Math.abs(i - j)) {
                    h++;
                }
            }
        }
        return h;
    }


    private void hillClimbingPlaceQueensRandomly() {
        for (int i = 0; i < n; i++) {
            int row = (int) (Math.random() * n);
            hillclimbingMoveQueen(i, row);
        }
    }

    private int hillclimbingGetQueenRow(int column) {
        for (int i = 0; i < n; i++) {
            if (queens[column][i]) {
                return i;
            }
        }
        return -1;
    }

    private void hillclimbingMoveQueen(int column, int row) {
        int currentRow = hillclimbingGetQueenRow(column);
        if (currentRow != -1) {
            queens[column][currentRow] = false;
        }
        queens[column][row] = true;
        hillclimbingUpdateBoard();
    }

    private void hillclimbingUpdateBoard() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (queens[j][i]) {
                    tiles[j][i].setBackground(Color.BLACK);
                } else {
                    tiles[j][i].setBackground(null);
                }
            }
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        //Action for pressing the enter button on the 'Enter N' GUI
        if (e.getSource() == createBoardButton) {
            
            try {
                int n = Integer.parseInt(inputField.getText());
                if (n >= 4) {
                    dispose();
                    NQueens nQueens = new NQueens(n);
                } else {
                    JOptionPane.showMessageDialog(null, "Invalid Input. Enter a value >= 4.");
                    return;
                }
            } catch (NumberFormatException ex) {
                JOptionPane.showMessageDialog(null, "Invalid Input. Enter a value >= 4.");
                return;
            }
        }
        
        else if(e.getSource() == leftButton) {
            boardsIndex--;
            boolean[][] currentBoard = boards.get(boardsIndex).clone();
            
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
														
                    if(currentBoard[j][i]) {
                        queens[j][i] = true;
															   
                    }
                    else {
                        queens[j][i] = false;
                    }
                }
            }
            
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (queens[j][i]) {
                        tiles[j][i].setBackground(Color.BLACK);
                    } else {
                        tiles[j][i].setBackground(null);
                    }
                }
            }

            if(boardsIndex == 0) {
                leftButton.setEnabled(false);
            }
            
            if(boardsIndex > 0) {
                rightButton.setEnabled(true);
            }
            
            outputArea.append("Showing Attempt #" + (boardsIndex + 1) + "\n");
        }
        
        else if(e.getSource() == rightButton) {
            boardsIndex++;
            boolean[][] currentBoard = boards.get(boardsIndex).clone();
            
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
														
                    if(currentBoard[j][i]) {
                        queens[j][i] = true;
															   
                    }
                    else {
                        queens[j][i] = false;
                    }
                }
            }
            
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (queens[j][i]) {
                        tiles[j][i].setBackground(Color.BLACK);
                    } else {
                        tiles[j][i].setBackground(null);
                    }
                }
            }
            
            if(boardsIndex == boards.size() - 1) {
                rightButton.setEnabled(false);
            }
            
            if(boardsIndex >= 1) {
                leftButton.setEnabled(true);
            }
            
            outputArea.append("Showing Attempt #" + (boardsIndex + 1) + "\n");
        }
        
        // Action for pressing the backtracking button
        else if (e.getSource() == backtrackingButton) {
            // Resets the board if a solution has been found and user selects an algorithm without hitting reset button
            if (solved) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        queens[j][i] = false;
                        tiles[j][i].setBackground(null);
                    }
                }
                outputArea.selectAll();
                outputArea.replaceSelection(null);
                solved = false;
            }

            int[] count = new int[1]; // Initialization for the amount of steps taken during one run of the backtracking algo
            backtracking(0, count);
        }
        
        // Action for pressing the hillclimbing button
        else if (e.getSource() == hillclimbingButton) {
            // Resets the board if a solution has been found and user selects an algorithm without 
            // hitting reset button
            if (solved) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        queens[j][i] = false;
                        tiles[j][i].setBackground(null);
                    }
                }
                
                // Clears the output area
                outputArea.selectAll();
                outputArea.replaceSelection(null);
                
                // Resets solved boolean
                solved = false;
            }

            int[] attempts = new int[1];
            attempts[0]++;
            hillclimbing(attempts);
        }
        
        // Action for pressing the reset button
        else if (e.getSource() == resetButton) {
            // Removes all queen positions and tile colors
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    queens[j][i] = false;
                    tiles[j][i].setBackground(null);
                }
            }
            
            // Clears the outputArea
            outputArea.selectAll();
            outputArea.replaceSelection(null);
            
            boards.clear();
            
            // Resets left and right board traversal buttons
            leftButton.setEnabled(false);
            rightButton.setEnabled(false);
            
            // Resets solved boolean
            solved = false;
        }
    }

    public static void main(String[] args) {
        NQueens nQueens = new NQueens();
    }
}
