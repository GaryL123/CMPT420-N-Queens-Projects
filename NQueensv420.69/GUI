package nqueens;

import java.util.Random;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class GUI extends JFrame implements ActionListener {
    private int n;
    private Random rand;
    private boolean solved;

    private JPanel boardPanel;
    private JButton[][] tiles;
    private boolean[][] queens;

    private JPanel buttonsPanel;
    private JButton backtrackingButton;
    private JButton hillclimbingButton;
    private JButton resetButton;

    private JTextArea outputArea;

    public GUI(int n) {
        // GUI is split into 3 sections
        // boardPanel contains the NQueens board
        // buttonPanel contains the Backtracking, Hillclimbing, and Reset buttons
        // outputArea contains the text outputted by either algorithm
        
        this.n = n;
        solved = false;
        rand = new Random();

        // Basic construction of the GUI window
        setTitle("NQueens"); // Title of the program
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Makes the program stop running when the window is closed. It would continue to run within NetBeans otherwise
        setSize(800, 600); // Width/Height of the window
        setLayout(new BorderLayout()); // Lets us layout the different panels of the GUI into different parts of the window

        // Creates the boardPanel area of the GUI
        boardPanel = new JPanel(new GridLayout(n, n)); // Constructs a new panel with a grid layout
        tiles = new JButton[n][n];
        queens = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                tiles[j][i] = new JButton();
                tiles[j][i].setOpaque(true);
                tiles[j][i].setPreferredSize(new Dimension(50, 50)); // Sets the size of the board's tiles
                boardPanel.add(tiles[j][i]);
            }
        }
        boardPanel.setPreferredSize(new Dimension(500, 500));
        boardPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
        add(boardPanel, BorderLayout.WEST);

        // Creates the buttons panel of the GUI
        buttonsPanel = new JPanel();
        backtrackingButton = new JButton("Recursive Backtracking");
        backtrackingButton.addActionListener(this);
        hillclimbingButton = new JButton("Steepest Ascent Hillclimbing");
        hillclimbingButton.addActionListener(this);
        resetButton = new JButton("Reset");
        resetButton.addActionListener(this);
        buttonsPanel.add(backtrackingButton);
        buttonsPanel.add(hillclimbingButton);
        buttonsPanel.add(resetButton);
        add(buttonsPanel, BorderLayout.SOUTH);

        // Creates the outputArea of the GUI
        outputArea = new JTextArea();
        outputArea.setEditable(false); // Makes it so the outputArea cannot be editted
        JScrollPane scrollPane = new JScrollPane(outputArea); // Makes the outputArea scrollable
        add(scrollPane, BorderLayout.CENTER);

        setVisible(true);
    }

    public void backtracking(int row, int[] count) {
        if(count[0] == 0) {
            int startingQueen = rand.nextInt(n);
            queens[0][startingQueen] = true;
            tiles[0][startingQueen].setBackground(Color.BLACK);
            count[0]++;
            outputArea.append(count[0] + ". Placed starting queen at (" + 0 + ", " + startingQueen + ")\n");
        }
        
        if (row == n) {
            // Returned if solution found
            solved = true;
            outputArea.append("Solved in: " + count[0] + " steps\n");
            return;
        }

        for (int col = 0; col < n; col++) {
            if (!backtrackingConflicts(row, col)) {
                queens[row][col] = true; // Adds a queen to this position on the board if there are no conflicts
                tiles[row][col].setBackground(Color.BLACK); // Sets the color of this position to green
                count[0]++; // Increments steps taken
                outputArea.append(count[0] + ". Placed queen at (" + (row + 1) + ", " + (col + 1) + ")\n"); // Adds this to the outputArea
                backtracking(row + 1, count); // Recursively calls the algo for the next row and updates the step count for the next recursion
                if (solved) {
                    return; // Breaks out of for loop when solution is found, else continues
                }
                queens[row][col] = false; // Removes a queen from this position if there are conflicts
                tiles[row][col].setBackground(null); // Removes the color from this position
                count[0]++; // Increments steps taken.
                outputArea.append(count[0] + ". Removed queen at (" + (row + 1) + ", " + (col + 1) + ")\n"); // Adds this to the outputArea
            }
        }
    }

    public boolean backtrackingConflicts(int row, int col) {
        for (int i = 0; i < row; i++) {
            int j = row - i;
            // Returns a conflict if there is a queen in the same column
            if (queens[i][col]) {
                return true;
            }
            
            if (queens[row][i]) {
                return true;
            }

            //Returns a conflict if there is a queen to the left diagonally
            if (col - j >= 0 && queens[i][col - j]) {
                return true;
            }

            //Returns a conflict if there is a queen to the right diagonally
            if (col + j < n && queens[i][col + j]) {
                return true;
            }
        }
        return false;
    }

    private void hillclimbing() {
        // Initialize the current state as a random arrangement of queens
        for (int i = 0; i < n; i++) {
            int j = rand.nextInt(n);
            queens[j][i] = true;
            tiles[j][i].setBackground(Color.GREEN);
        }
        int currentHeuristic = hillclimbingHeuristics(queens);

        // Perform the hillclimbing search
        int iterations = 0;
        while (currentHeuristic > 0 && iterations < 1000) {
            iterations++;
            int bestHeuristic = currentHeuristic;
            int[] bestMove = new int[2];

            // Generate all possible successor states
            for (int i = 0; i < n; i++) {
                int currentRow = -1;
                for (int j = 0; j < n; j++) {
                    if (queens[i][j]) {
                        currentRow = i;
                        break;
                    }
                }
                for (int j = 0; j < n; j++) {
                    if (j != currentRow) {
                        queens[i][j] = true;
                        queens[i][currentRow] = false;
                        int newHeuristic = hillclimbingHeuristics(queens);
                        if (newHeuristic < bestHeuristic) {
                            bestHeuristic = newHeuristic;
                            bestMove[0] = i;
                            bestMove[1] = j;
                        }
                        queens[i][j] = false;
                        queens[i][currentRow] = true;
                    }
                }
            }

            // Select the best successor state if it has a lower heuristic value
            if (bestHeuristic < currentHeuristic) {
                queens[bestMove[0]][bestMove[1]] = true;
                queens[bestMove[0]][bestMove[0]] = false;
                tiles[bestMove[0]][bestMove[1]].setBackground(Color.GREEN);
                tiles[bestMove[0]][bestMove[0]].setBackground(null);
                currentHeuristic = bestHeuristic;
            } else {
                break;
            }
        }

        // Update the GUI and set the solved flag
        if (currentHeuristic == 0) {
            outputArea.append("Solution found!\n");
            solved = true;
        } else {
            outputArea.append("No solution found, trying again.\n");
            reset(n);
            hillclimbing();
        }
    }

    private int hillclimbingHeuristics(boolean[][] queens) {
        int conflicts = 0;

        // Check row conflicts
        for (int i = 0; i < n; i++) {
            boolean conflict = false;
            for (int j = 0; j < n; j++) {
                if (queens[i][j]) {
                    if (conflict) {
                        conflicts++;
                    }
                    conflict = true;
                } else {
                    conflict = false;
                }
            }
        }

        // Check column conflicts
        for (int j = 0; j < n; j++) {
            boolean conflict = false;
            for (int i = 0; i < n; i++) {
                if (queens[i][j]) {
                    if (conflict) {
                        conflicts++;
                    }
                    conflict = true;
                } else {
                    conflict = false;
                }
            }
        }

        // Check diagonal conflicts
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (queens[i][j]) {
                    for (int k = 1; k < n; k++) {
                        if (i - k >= 0 && j - k >= 0 && queens[i - k][j - k]) {
                            conflicts += 2;
                        }
                        if (i - k >= 0 && j + k < n && queens[i - k][j + k]) {
                            conflicts += 2;
                        }
                    }
                }
            }
        }

        // Penalize invalid states more heavily
        if (conflicts > 0) {
            conflicts += 50;
        }

        return conflicts;
    }

    public void reset(int n) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                queens[i][j] = false;
                tiles[i][j].setBackground(null);
            }
        }
    }

    //Method to tell GUI what to do when a button is pressed
    @Override
    public void actionPerformed(ActionEvent e) {
        // Action for pressing the backtracking button
        if (e.getSource() == backtrackingButton) {
            //Places a starting queen in a random column of row 0
            /*int startingQueen = rand.nextInt(n);
            queens[startingQueen][0] = true;
            outputArea.append("Placed queen at (" + startingQueen + ", " + 0 + ")\n");
            tiles[0][startingQueen].setBackground(Color.RED);*/
            
            int[] count = new int[1]; // Initialization for the amount of steps taken during one run of the backtracking algo
            long start = System.currentTimeMillis(); // Gets the current time before the backtracking algo starts
            backtracking(0, count);
            long end = System.currentTimeMillis(); // Gets the current time after the backtracking algo stops
            outputArea.append("Elapsed time: " + (end - start) + " ms\n");
        }
        
        // Action for pressing the hillclimbing button
        else if (e.getSource() == hillclimbingButton) {
            long start = System.currentTimeMillis(); // Gets the current time before the hillclimbing algo starts
            hillclimbing();
            long end = System.currentTimeMillis(); // Gets the current time after the hillclimbing algo stops
            outputArea.append("Elapsed time: " + (end - start) + " ms\n");
        }
        
        // Action for pressing the reset button
        else if (e.getSource() == resetButton) {
            // Closes the current GUI window and regenerates a new one
            //dispose();
            //new GUI(n);
            reset(n);
        }
    }
}
